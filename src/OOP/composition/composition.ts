/**
 * Класс Engine.
 * Представляет двигатель автомобиля.
 * - Метод `drive` запускает работу двигателя.
 */
class Engine {
    drive() {
        console.log('Двигатель работает')
    }
}

/**
 * Класс Wheel
 * Представляет одно колесо автомобиля.
 * - Метод `drive` моделирует вращение колес.
 */
class Wheel {
    drive() {
        console.log('Колёса крутятся')
    }

}

/**
 * Класс Car
 * Представляет автомобиль, использующий композицию.
 * - Включает в себя объекты Engine и Wheel.
 * - Делегирует работу двигателя и колес их соответствующим объектам.
 * - Конструктор позволяет передавать тип двигателя и количество колес.
 */

class Car {
    engine: Engine;
    wheels: Wheel[] = [];

    constructor(wheelsCount: number = 4) {
        this.engine = new Engine();
        for (let i = 0; i < wheelsCount; i++) {
            this.wheels.push(new Wheel());  // Добавляем нужное количество колес
        }
    }

    /**
     * Метод `drive` делегирует задачу по запуску двигателя и вращению колес.
     * Это пример композиции, где Car делегирует работу другим объектам (engine и wheels).
     */
    drive() {
        this.engine.drive();
        this.wheels.forEach(wheel => wheel.drive())
    }

}

const car = new Car();

car.drive()

/**
 * Преимущества композиции:
 * 1. Гибкость: Легко заменять компоненты.
 * 2. Модульность: Каждый компонент выполняет свою узкую задачу.
 * 3. Слабая связанность: Каждый компонент можно изменить без изменения других.
 * 4. Расширяемость: Можно добавлять новые компоненты (например, другие типы двигателей или колес).
 */