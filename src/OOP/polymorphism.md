## Полиморфизм

### Ключевые аспекты полиморфизма:

1. **Единый интерфейс, разное поведение:**
   Полиморфизм позволяет использовать один и тот же интерфейс (например, метод с одинаковым названием) для работы с разными типами объектов. Поведение зависит от того, как метод реализован в каждом конкретном классе.
2. **Динамическая диспетчеризация:**
   Решение о том, какой метод вызывать, принимается **на этапе выполнения** программы, а не на этапе компиляции.
3. **Основывается на наследовании или интерфейсах:**
   Для полиморфизма необходима общая связь между классами — либо через наследование, либо через реализацию интерфейса.
4. **Переопределение методов:**
   Ключевая техника в полиморфизме — переопределение методов в классах-наследниках для предоставления их уникальной реализации.

### Типы полиморфизма

1. **Ad-hoc полиморфизм (перегрузка методов):**
   Один метод может принимать аргументы разных типов или разное их количество. Это статический полиморфизм, который компилятор разрешает на этапе компиляции.
2. **Инклюзивный полиморфизм (наследование и переопределение):**
   Позволяет объекту дочернего класса использовать интерфейс родительского, но при этом выполнять свою реализацию. Это динамический полиморфизм.

### Базовый пример

```typescript
class Shape {
    public area(): number {
        throw new Error("Метод 'area' должен быть переопределён!");
    }
}

// Класс-наследник: Круг
class Circle extends Shape {
    private radius: number;

    constructor(radius: number) {
        super();
        this.radius = radius;
    }

    public area(): number {
        return Math.PI * this.radius ** 2; // Формула площади круга
    }
}

// Класс-наследник: Прямоугольник
class Rectangle extends Shape {
    private width: number;
    private height: number;

    constructor(width: number, height: number) {
        super();
        this.width = width;
        this.height = height;
    }

    public area(): number {
        return this.width * this.height; // Формула площади прямоугольника
    }
}

// Использование полиморфизма
const shapes: Shape[] = [new Circle(5), new Rectangle(4, 6)];

shapes.forEach((shape) => {
    console.log(`Площадь фигуры: ${shape.area()}`);
});

```

### Глубокие аспекты полиморфизма:

1. **Принцип подстановки Лисков (Liskov Substitution Principle, LSP):**
   Ключевой принцип, поддерживающий полиморфизм. Объект любого подкласса должен быть заменяемым на объект родительского класса, не нарушая поведения программы.
   Например:
   ```typescript
   const shape: Shape = new Circle(5);
   console.log(shape.area()); // Корректно, если соблюдён LSP

   ```
2. **Связь с инкапсуляцией:**
   Полиморфизм позволяет скрывать детали реализации, предоставляя общий интерфейс. Мы знаем, что у фигуры есть метод `area`, но не заботимся о том, как он реализован.
3. **Расширяемость:**
   Благодаря полиморфизму вы можете добавлять новые подклассы, не модифицируя существующий код. Это основа принципа **Open-Closed Principle (OCP)**: *класс открыт для расширения, но закрыт для модификации*.
4. **Связь с Dependency Inversion Principle (DIP):**
   Код должен зависеть от абстракций, а не от конкретных реализаций. Полиморфизм помогает в этом, так как мы работаем с родительским классом или интерфейсом, а не с конкретными объектами.
