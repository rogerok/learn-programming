# Высококачественные методы

## 7.2 Проектирование на уровне методов

### Приемлемые типы связанностей:

- _Функциональная связность_ — самый сильный и лучший вид связности; она имеет место,
  когда метод выполняет одну и только одну операцию. Примерами мето
  дов, обладающих высокой связностью, являются методы `sin()` (синус), `GetCustomerName()` (получить фамилию заказчика),
  `EraseFile()` (удалить файл), `CalculateLoanPayment()` (вычислить плату за кредит)
  и `AgeFromBirthdate()` (определить возраст по дате рождения). Конечно, такая оценка связности предполагает, что эти
  методы соответствуют своим именам — иначе они имеют неудачные имена, а об
  их связности нельзя сказать ничего определенного.
- Последовательная связанность - метод выполняет несколько операций, которые _обязательно_ выполняются в определенном
  порядке и используют данные предыдущих этапов вычислений в единую функцию.

```typescript
function processRetirement(birthDate: Date): void {
  const age = getAge(birthDate); // 1. Используется далее
  const yearsToRetirement = getYearsToRetirement(age); // 2. Зависит от предыдущего
  console.log(`Years until retirement: ${yearsToRetirement}`);
}
```

Решение - вынести каждый шаг в отдельный метод с _функциональной связанностью_.

- _Коммуникационная связность_ - метод выполняет несколько операций, которые используют _одни и те же данные_, но
  логически _никак не связаны между собой_.

```typescript
function processCustomerAccount(customer: Customer): void {
  updateCreditScore(customer); //  Финансовая логика
  sendPromotionalEmail(customer); //  Маркетинг
}
```

Решение - разделить методы.

```typescript
function updateFinancialData(customer: Customer): void {
  updateCreditScore(customer);
}

function runMarketingWorkflow(customer: Customer): void {
  sendPromotionalEmail(customer);
}
```

- _Временная связность_ - операции сгруппированы, только потому что выполняются в одно и то же время. Например
  инициализация приложения.

```typescript
function startup(): void {
  readConfig();
  initLogging();
  createDefaultFiles();
  connectToDatabase();
}
```

## _Методы следует называть абстрактно_ - это даёт понять что это организующая логика, а не конкретные действия.

### Неприемлемые типы связности

- _Процедурная_ - операции в методы соединены только порядком выполнения, но не логикой.

```typescript
function submitForm() {
  const name = this.getNameInput();
  const email = this.getEmailInput();
  const phone = this.getPhoneInput();

  if (!this.validateName(name)) {
    this.showError("Invalid name");
    return;
  }

  if (!this.validateEmail(email)) {
    this.showError("Invalid email");
    return;
  }

  if (!this.validatePhone(phone)) {
    this.showError("Invalid phone");
    return;
  }

  this.sendToServer(name, email, phone);
}
```

Решение - выделять каждую логическую подзадачу в отдельный метод

```typescript
async function handleSubmit(): Promise<void> {
  const data = this.getFormData();

  const errors = this.validateForm(data);
  if (errors.length > 0) {
    this.showErrors(errors);
    return;
  }

  await this.submitToServer(data);
  this.showSuccess();
}
```

- Логическая связность - это когда метод делает несколько операций, выбор которых зависит от флага или `enum`, но сами
  эти операции _никак логически не связаны_.
  Их единственная связь - флаг выбора.

Плохой пример

```typescript
function handleAction(
  actionType: "save" | "print" | "sendEmail",
  data: Document,
): void {
  if (actionType === "save") {
    saveToDisk(data);
  } else if (actionType === "print") {
    printDocument(data);
  } else if (actionType === "sendEmail") {
    sendEmailWithAttachment(data);
  }
}
```

Решение

1. Создаём интерфейс общего поведения

```typescript
interface DocumentAction {
  execute: (data: Document) => void;
}
```

2. Реализации

```typescript
class SaveAction implements DocumentAction {
  execute(data: Document) {
    saveToDisk(document);
  }
}

class Print implements DocumentAction {
  execute(data: Document) {
    print(document);
  }
}

class EmailAction implements DocumentAction {
  execute(data: Document) {
    sendEmailWithAttach(document);
  }
}
```

3. Инкапсуляция выбора (стратегия, фабрика):

```typescript
function getAction(actionType: "save" | "print" | "sendEmail"): DocumentAction {
  switch (actionType) {
    case "save":
      return new SaveAction();
    case "print":
      return new PrintAction();
    case "sendEmail":
      return new EmailAction();
    default:
      2;
      throw new Error("Unknown action type");
  }
}
```

```typescript
function handleAction(
  actionType: "save" | "print" | "sendEmail",
  data: Document,
): void {
  const action = getAction(actionType);
  action.execute(data);
}
```
