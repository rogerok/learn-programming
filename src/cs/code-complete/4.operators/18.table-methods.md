
# 18 Табличные методы

## 18.2 Таблицы с прямым доступом
Имеют "прямой доступ", с помощью которого мы можем выбрать непосредственно нужную запись.
Для того чтобы ей найти, не нужно ходить по кругу.
Таблица с прямым доступом позволяет обратиться к элементу напрямую.

### Суть табличного подхода
_Допустим, вы разрабатываете метод для печати сообщений, хранящихся в файле.
Обычно файл содержит около 500 сообщений, которые бывают примерно 20 видов.
Изначально сообщения поступают от бакенов и включают в себя информацию о
температуре воды, расположении бакена и т. д._

Вместо того чтобы писать *отдельные функции* для каждого типа сообщений, мы создаем таблицу, где описываем
- имя сообщения
- какие поля в нём есть
- тип каждого поля

После этого уже создаём обобщенную функцию, которая:
1) получает описания сообщения из таблицы;
2) по полю `FieldType` вызывает нужный метод для чтения и записи значения.

```typescript
// 1. Описываем типы полей
enum FieldType {
    FloatingPoint,
    Integer,
    String,
    TimeOfDay,
    Boolean,
    BitField
}
// 2. Описание поля в сообщении
interface FieldDescription {
    fieldType: FieldType;
    fieldName: string;
}
// 3. Описание структуры сообшения 

interface MessageDescription {
    messageName: string;
    fields: FieldDescription[];
}

// 4. Абстрактный класс для обработки поля

abstract class AbstractField {
    abstract readAndPrint(fieldName: string, rawValue: any): void;
}

// 5. Реализация для каждого типа

class FloatingPointField extends AbstractField {
    readAndPrint(fieldName: string, rawValue: any) {
        console.log(`${fieldName}: ${parseFloat(rawValue).toFixed(2)}`);
    }
}

class IntegerField extends AbstractField {
    readAndPrint(fieldName: string, rawValue: any): void {
        console.log(`${fieldName}: ${parseInt(rawValue, 10)}`);
    }
}

class StringField extends AbstractField {
    readAndPrint(fieldName: string, rawValue: any): void {
        console.log(`${fieldName}: ${String(rawValue)}`);
    }
}

class TimeOfDayField extends AbstractField {
    readAndPrint(fieldName: string, rawValue: any): void {
        const date = new Date(rawValue);
        console.log(`${fieldName}: ${date.toLocaleTimeString()}`);
    }
}

class BooleanField extends AbstractField {
    readAndPrint(fieldName: string, rawValue: any): void {
        console.log(`${fieldName}: ${Boolean(rawValue)}`);
    }
}

class BitFieldField extends AbstractField {
    readAndPrint(fieldName: string, rawValue: any): void {
        console.log(`${fieldName}: 0b${Number(rawValue).toString(2)}`);
    }
}
// 6. Таблица обработчиков по типу поля 

const fieldHandlers: Record<FieldType, AbstractField> = {
    [FieldType.FloatingPoint]: new FloatingPointField(),
    [FieldType.Integer]: new IntegerField(),
    [FieldType.String]: new StringField(),
    [FieldType.TimeOfDay]: new TimeOfDayField(),
    [FieldType.Boolean]: new BooleanField(),
    [FieldType.BitField]: new BitFieldField(),
};

// Шаг 7: Пример описания сообщения
const messages: MessageDescription[] = [
    {
        messageName: "Buoy Temperature Message",
        fields: [
            { fieldType: FieldType.FloatingPoint, fieldName: "Average Temperature" },
            { fieldType: FieldType.FloatingPoint, fieldName: "Temperature Range" },
            { fieldType: FieldType.Integer, fieldName: "Number of Samples" },
            { fieldType: FieldType.String, fieldName: "Location" },
            { fieldType: FieldType.TimeOfDay, fieldName: "Time of Measurement" },
        ],
    },
];

// Шаг 8: Обработка сообщения по таблице
function processMessage(
    message: MessageDescription,
    rawData: Record<string, any>
): void {
    console.log(`Message: ${message.messageName}`);
    for (const field of message.fields) {
        const value = rawData[field.fieldName];
        const handler = fieldHandlers[field.fieldType];
        handler.readAndPrint(field.fieldName, value);
    }
}

```

