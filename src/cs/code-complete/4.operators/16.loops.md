# Циклы

### Цикл с выходом

Цикл, который гарантированно должен выполниться хотя бы один раз

```typescript
async function pollUntilReady(): Promise<void> {
    let attempts = 0;

    while (true) {
        const status = await fetchStatus();

        if (status === "ready" || attempts > 10) {
            break;
        }

        await delay(1000);
        attempts++;
    }
}
```

----

### Аномальные циклы с выходом

Цикл, в котором часть логики нужно выполнить ДО проверки условия, а другая — только если условие пройдено.

```typescript
while (true) {
    prepare(); // выполняется каждый раз, включая до первой проверки

    if (!hasNext()) {
        break;
    }

    process(); // выполняется только если условие пройдено
}
```

----

## Управление циклом

В первую очередь следует минимизировать кол-во факторов влияющих на цикл.
Цикл можно рассматривать как метод - вынести за пределы цикла все управление, какое только возможно.
Явно объявить условия выполнения тела цикла, без необходимости заглядывания внутрь цикла, чтобы понять его управление.
Например

```typescript
while (!inputFile.EndOfFile() && someCheck) {
    // do something
}
```

----

## Завершение цикла

Используй continue — но строго в начале цикла

```typescript
for (const item of items) {
    if (!isValid(item)) continue;

    // обработка валидных данных
}
```

Уменьшает вложенность, делает цикл плоским и читаемым.
----

## Проверка граничных точек

_Проверь три ключевые точки цикла:_

- Первая итерация
- Произвольная итерация
- Последняя итерация

Это помогает

- Найти ошибку потери единицы
- Проверить корректность условий выхода
- Убедиться что нет неожиданных пусков и повторов.

**НЕ НУЖНО**
"наощупь" перебирать `</<=, i++/i--, i + 1, i - 1`

Пример: цикл с ошибкой потери единицы

```typescript 
for (let i = 0; i <= items.length; i++) {
    process(items[i]); // ❌ последняя итерация вызывает items[items.length] → undefined
}
```

Мысленное моделирование:

* `items.length === 5`
* `i` принимает значения `0,1,2,3,4,5`

_Если есть спец-логика на первой или последней итерации — тестируй её явно:_

```typescript
for (let i = 0; i < items.length; i++) {
    if (i === 0) {
        // особая логика первой итерации
    }

    if (i === items.length - 1) {
        // особая логика последней итерации
    }
}
```

## Кодирование цикла изнутри наружу

### Что значит «кодировать цикл изнутри наружу»?

1. Начинаешь с маленького, конкретного действия, не думая сразу про весь цикл.
2. Потом оборачиваешь это действие циклом, заменяешь фиксированные значения на переменные.
3. Если нужно — добавляешь вложенные циклы, по тому же принципу.
4. В конце — добавляешь инициализацию и общее управление.

---

## Почему это работает?

- Меньше ошибок — работаешь с небольшими кусочками, проще проверить.
- Лучше понимаешь код — ясно, что происходит на каждом шаге.
- Проще отлаживать — легче локализовать ошибки.
- Плавное усложнение — не надо думать обо всём сразу.

---

## Пример: считаем общую страховую премию

- Шаг 1: Один человек — конкретная ставка

```ts
const rate = 100; // ставка для одного человека
let totalRate = 0;
totalRate += rate;
```

- Шаг 2: Добавляем структуру данных (без индексов)

```typescript
const table = [
    [50, 60],  // ставки по возрасту и полу
    [70, 80],
];

const census = [
    {Age: 0, Gender: 1},
];

let totalRate = 0;

// Без цикла берем первого человека
const rate = table[census[0].Age][census[0].Gender];
totalRate += rate;
```

- Шаг 3: Добавляем цикл по группе людей

```typescript
const table = [
    [50, 60],
    [70, 80],
];

const census = [
    {Age: 0, Gender: 1},
    {Age: 1, Gender: 0},
];

let totalRate = 0;

for (let person = 0; person < census.length; person++) {
    const rate = table[census[person].Age][census[person].Gender];
    totalRate += rate;
}
```

