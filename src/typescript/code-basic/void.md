# Использование типа Void

`void` автоматически выводится, когда внутри функции нет инструкции return или она пустая:

```ts
function noop() {
  // внутри пусто
}
```

В JavaScript подобные функции возвращают `undefined`, но в TypeScript `void` и `undefined` — это разные вещи. Они различаются по контекстной типизации. А происходит это из-за особенностей работы самого JavaScript. Самый яркий пример — метод `forEach()`.

Метод `forEach()` не использует данные, возвращаемые переданным колбеком, который вызывается внутри. Возможно, логично было бы определить возврат как `undefined`, но посмотрим на пример:


```ts 
const numbers = [1, 2, 3];
const result = [];

numbers.forEach((n) => result.push(n));
```

Метод `push()` возвращает новую длину массива. Если бы `forEach()` требовал от колбека возврат `undefined`, то такой код привел бы к ошибке компиляции. Его пришлось бы переписать, например, так:


```ts
// Теперь колбек ничего не возвращает,
// соответственно, результат вызова undefined
numbers.forEach((n) => {
  result.push(n);
});
```


Чтобы не писать такой код, и был введен `void`. Он позволяет возвращать любые данные, но делает так, что их использование бессмысленно.

Мы можем определить тип функции, который возвращает `void`, и использовать его для типизации переменной:


```ts
type VoidFunc = () => void;

// Тип функции определяется через контекст
// присваивания ее переменной с типом VoidFunc
const f: VoidFunc = () => true;

const v = f();
```

Хотя `f()` возвращает `true`, переменная `v` имеет тип `void`. Это означает, что мы не можем использовать ее для чего-либо, кроме как для присваивания другой переменной с типом `void`


```ts
function foo(): void {
  return true; // Error!
}

const bar = function(): void {
  return true; // Error!
};
```

Сценарий 2: Явное указание типа (function foo(): void)


```ts
function foo(): void {
  return true; // Error!
}
```

Здесь нет никакого "контекста присваивания". Вы не пытаетесь "подогнать" одну функцию под другую. Вы напрямую создаете новую функцию и даете ей строгое, явное обязательство: "Эта функция foo по своей природе не должна возвращать никакого значения".

Когда компилятор видит `return true`;, он проверяет это прямое обязательство.

Обязательство: "Не возвращать значение".
Действие в коде: "Вернуть значение `true`".
Результат: Нарушение контракта. Ошибка компиляции.
Здесь нет никуда "девать" возвращаемое значение, потому что сама суть функции, как вы ее объявили, — не возвращать ничего.