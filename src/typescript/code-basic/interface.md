# Об интерфейсах

Главная особенность интерфейсов связана с классами. Классы, которые реализуют интерфейсы, содержат внутри себя свойства и методы, указанные в реализуемом интерфейсе:

```ts
interface Countable {
  count(): number;
}

class SchoolClass implements Countable {
  // Тут какая-то логика
  count(): number {
    // Обязательно создать этот метод, так как он указан в интерфейсе
  }
}

const sc = new SchoolClass();
// Возвращает число студентов в классе
sc.count();
```

В этом примере мы реализовали класс на основе интерфейса. Теперь во всех функциях, где объекты используются только для того, чтобы посчитать количество чего-либо внутри них, можно указывать Countable вместо SchoolClass:

```ts
// А не function doSomething(obj: SchoolClass)
function doSomething(obj: Countable) {
  // Где-то внутри вызывается
  obj.count();
}
```

# Отличительные особенности интерфейсов

## Расширение интерфейса дополнительными полями

Интерфейсам доступно *слияние деклараций*  
```ts
interface IUser {
  rating: number;
}

interface IUser {
  nickname: string;
  birthdate: number;
}

const sergey: IUser = {
  nickname: 'Sergey',
  birthdate: 1990,
  rating: 1102,
}
```

Здесь мы создали интерфейс IUser, а затем для демонстрационных целей расширили его новыми свойствами. После этого создали на его основе объект Sergey.

# Реализация интерфейсов классами

## Создание классов на основе интерфейсов
Мы можем создавать классы на основе интерфейсов так же, как мы создаем интерфейсы на основе интерфейсов. Но есть и отличия.
Если мы создаем интерфейс или тип и потом транспилируем TypeScript в JavaScript, то в коде не останется образца этого интерфейса.
В то же время при создании класса его образец всегда переносится и в JavaScript при транспиляции.
Получается, что вариант с интерфейсами более легковесный.



Создание класса на основе интерфейса не ведет к точной реализации этого интерфейса в классе.
TypeScript просто проверяет, удовлетворяют ли свойства и методы нашего класса, свойствам заявленным в интерфейсе.
Сам класс мы же пишем вручную

```ts
interface ICalculate {
    sum: (num1: number, num2: number) => number
}

class Summator implements ICalculate {
    sum(num1, num2) { return num1 + num2; }
    // Для параметров будет выведено сообщение: Parameter 'num1'/'num2' implicitly has an 'any' type,
    // потому что TypeScript только проверяет класс на соответствие интерфейсу, но не наследуется от него полноценно


    multiply(num1: number, num2: number) { return num1 * num2; }
    // Мы добавили новый метод, но TypeScript не ругается
}

let calculator = new Summator();
// Наш код сработает, как если бы он сработал для аргументов с типом any,
// потому что типы параметров, равно как и все остальное, не были унаследованы классом при реализации интерфейса
calculator.sum(2,3) // 5
```

Ошибка в реализации интерфейса классом возможна только тогда, когда мы не реализуем одно из свойств, указанных в интерфейсе. Или мы реализуем его не так, как указано в интерфейсе

Если мы пишем класс, реализующий интерфейс с опциональными свойствами, нам нужно прописывать все самостоятельно.
В противном случае эти свойства не попадут в наш класс:

```ts
interface ICalculate {
  sum: (num1: number, num2: number) => number;
  multiply? : (num1: number, num2: number) => number;
}

class Summator implements ICalculate {
  sum (num1: number, num2: number) { return num1 + num2; }
}

const calculator = new Summator();
calculator.sum(2,3) // 5
calculator.multiply(2,3) // Property 'multiply' does not exist on type 'Summator'.
```

